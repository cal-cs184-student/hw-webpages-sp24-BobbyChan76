<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_1k9f929ifvzg-7{list-style-type:none}ul.lst-kix_4qc2v0utgup0-1{list-style-type:none}ul.lst-kix_1k9f929ifvzg-6{list-style-type:none}ul.lst-kix_4qc2v0utgup0-0{list-style-type:none}ul.lst-kix_1k9f929ifvzg-5{list-style-type:none}ul.lst-kix_1k9f929ifvzg-4{list-style-type:none}ul.lst-kix_4qc2v0utgup0-5{list-style-type:none}ul.lst-kix_4qc2v0utgup0-4{list-style-type:none}ul.lst-kix_4qc2v0utgup0-3{list-style-type:none}ul.lst-kix_1k9f929ifvzg-8{list-style-type:none}ul.lst-kix_4qc2v0utgup0-2{list-style-type:none}ul.lst-kix_4qc2v0utgup0-8{list-style-type:none}ul.lst-kix_xejd8s2iujbr-8{list-style-type:none}ul.lst-kix_4qc2v0utgup0-7{list-style-type:none}ul.lst-kix_xejd8s2iujbr-7{list-style-type:none}ul.lst-kix_4qc2v0utgup0-6{list-style-type:none}ul.lst-kix_xejd8s2iujbr-6{list-style-type:none}ul.lst-kix_xejd8s2iujbr-5{list-style-type:none}ul.lst-kix_xejd8s2iujbr-4{list-style-type:none}ul.lst-kix_xejd8s2iujbr-3{list-style-type:none}.lst-kix_hhn1i4512df1-8>li:before{content:"\0025a0   "}.lst-kix_hhn1i4512df1-7>li:before{content:"\0025cb   "}ul.lst-kix_1k9f929ifvzg-3{list-style-type:none}ul.lst-kix_1k9f929ifvzg-2{list-style-type:none}ul.lst-kix_1k9f929ifvzg-1{list-style-type:none}ul.lst-kix_1k9f929ifvzg-0{list-style-type:none}.lst-kix_hhn1i4512df1-6>li:before{content:"\0025cf   "}.lst-kix_hhn1i4512df1-3>li:before{content:"\0025cf   "}.lst-kix_hhn1i4512df1-5>li:before{content:"\0025a0   "}.lst-kix_hhn1i4512df1-0>li:before{content:"\0025cf   "}.lst-kix_hhn1i4512df1-4>li:before{content:"\0025cb   "}.lst-kix_hhn1i4512df1-1>li:before{content:"\0025cb   "}.lst-kix_hhn1i4512df1-2>li:before{content:"\0025a0   "}ul.lst-kix_xejd8s2iujbr-2{list-style-type:none}ul.lst-kix_xejd8s2iujbr-1{list-style-type:none}.lst-kix_xejd8s2iujbr-5>li:before{content:"\0025a0   "}.lst-kix_xejd8s2iujbr-6>li:before{content:"\0025cf   "}ul.lst-kix_xejd8s2iujbr-0{list-style-type:none}.lst-kix_xejd8s2iujbr-7>li:before{content:"\0025cb   "}.lst-kix_xejd8s2iujbr-8>li:before{content:"\0025a0   "}.lst-kix_xejd8s2iujbr-2>li:before{content:"\0025a0   "}.lst-kix_xejd8s2iujbr-3>li:before{content:"\0025cf   "}.lst-kix_xejd8s2iujbr-4>li:before{content:"\0025cb   "}.lst-kix_pf4spjyd00kr-6>li:before{content:"\0025cf   "}.lst-kix_xejd8s2iujbr-1>li:before{content:"\0025cb   "}.lst-kix_pf4spjyd00kr-7>li:before{content:"\0025cb   "}.lst-kix_xejd8s2iujbr-0>li:before{content:"\0025cf   "}.lst-kix_pf4spjyd00kr-8>li:before{content:"\0025a0   "}ul.lst-kix_pf4spjyd00kr-3{list-style-type:none}ul.lst-kix_pf4spjyd00kr-2{list-style-type:none}ul.lst-kix_pf4spjyd00kr-1{list-style-type:none}ul.lst-kix_pf4spjyd00kr-0{list-style-type:none}ul.lst-kix_pf4spjyd00kr-7{list-style-type:none}ul.lst-kix_pf4spjyd00kr-6{list-style-type:none}ul.lst-kix_pf4spjyd00kr-5{list-style-type:none}ul.lst-kix_pf4spjyd00kr-4{list-style-type:none}ul.lst-kix_pf4spjyd00kr-8{list-style-type:none}.lst-kix_1k9f929ifvzg-3>li:before{content:"\0025cf   "}.lst-kix_1k9f929ifvzg-4>li:before{content:"\0025cb   "}.lst-kix_1k9f929ifvzg-5>li:before{content:"\0025a0   "}.lst-kix_1k9f929ifvzg-6>li:before{content:"\0025cf   "}.lst-kix_1k9f929ifvzg-8>li:before{content:"\0025a0   "}.lst-kix_1k9f929ifvzg-7>li:before{content:"\0025cb   "}.lst-kix_1k9f929ifvzg-2>li:before{content:"\0025a0   "}.lst-kix_1k9f929ifvzg-1>li:before{content:"\0025cb   "}.lst-kix_1k9f929ifvzg-0>li:before{content:"\0025cf   "}.lst-kix_pf4spjyd00kr-1>li:before{content:"\0025cb   "}.lst-kix_pf4spjyd00kr-3>li:before{content:"\0025cf   "}.lst-kix_pf4spjyd00kr-2>li:before{content:"\0025a0   "}.lst-kix_pf4spjyd00kr-5>li:before{content:"\0025a0   "}.lst-kix_pf4spjyd00kr-4>li:before{content:"\0025cb   "}.lst-kix_pf4spjyd00kr-0>li:before{content:"\0025cf   "}ul.lst-kix_hhn1i4512df1-2{list-style-type:none}ul.lst-kix_hhn1i4512df1-3{list-style-type:none}ul.lst-kix_hhn1i4512df1-4{list-style-type:none}ul.lst-kix_hhn1i4512df1-5{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-0{list-style-type:none}ul.lst-kix_hhn1i4512df1-6{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-1{list-style-type:none}ul.lst-kix_hhn1i4512df1-7{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-2{list-style-type:none}ul.lst-kix_hhn1i4512df1-8{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-3{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-4{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-5{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-6{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-7{list-style-type:none}ul.lst-kix_qv5n0jwtl5za-8{list-style-type:none}ul.lst-kix_hhn1i4512df1-0{list-style-type:none}ul.lst-kix_hhn1i4512df1-1{list-style-type:none}.lst-kix_qv5n0jwtl5za-6>li:before{content:"\0025cf   "}.lst-kix_qv5n0jwtl5za-8>li:before{content:"\0025a0   "}.lst-kix_4qc2v0utgup0-0>li:before{content:"\0025cf   "}.lst-kix_qv5n0jwtl5za-7>li:before{content:"\0025cb   "}.lst-kix_4qc2v0utgup0-3>li:before{content:"\0025cf   "}.lst-kix_qv5n0jwtl5za-4>li:before{content:"\0025cb   "}.lst-kix_4qc2v0utgup0-1>li:before{content:"\0025cb   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_4qc2v0utgup0-2>li:before{content:"\0025a0   "}.lst-kix_qv5n0jwtl5za-5>li:before{content:"\0025a0   "}.lst-kix_4qc2v0utgup0-7>li:before{content:"\0025cb   "}.lst-kix_qv5n0jwtl5za-0>li:before{content:"\0025cf   "}.lst-kix_4qc2v0utgup0-4>li:before{content:"\0025cb   "}.lst-kix_4qc2v0utgup0-8>li:before{content:"\0025a0   "}.lst-kix_qv5n0jwtl5za-3>li:before{content:"\0025cf   "}.lst-kix_qv5n0jwtl5za-2>li:before{content:"\0025a0   "}.lst-kix_4qc2v0utgup0-5>li:before{content:"\0025a0   "}.lst-kix_4qc2v0utgup0-6>li:before{content:"\0025cf   "}.lst-kix_qv5n0jwtl5za-1>li:before{content:"\0025cb   "}ol{margin:0;padding:0}table td,table th{padding:0}.c2{-webkit-text-decoration-skip:none;color:#333333;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:15pt;font-family:"Arial";font-style:normal}.c17{margin-left:72pt;padding-top:0pt;padding-left:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{-webkit-text-decoration-skip:none;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{color:#333333;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Courier New";font-style:normal}.c24{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c23{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c16{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c10{-webkit-text-decoration-skip:none;color:#333333;font-weight:700;text-decoration:underline;text-decoration-skip-ink:none;font-size:15pt}.c26{color:#000000;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c8{font-weight:700;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c12{font-weight:400;text-decoration:none;vertical-align:baseline;font-family:"Arial";font-style:normal}.c19{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c14{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c27{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c28{color:#333333;font-size:13pt}.c7{font-style:italic;font-weight:700}.c0{color:#333333;font-size:12pt}.c21{color:#333333;font-size:11pt}.c30{color:#000000;font-size:11pt}.c22{font-size:10pt;color:#333333}.c1{padding:0;margin:0}.c18{border:1px solid black;margin:5px}.c13{font-size:14pt;color:#333333}.c20{margin-left:36pt}.c25{margin-left:72pt}.c11{font-weight:700}.c29{height:11pt}.c15{font-family:"Courier New"}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c27 doc-content"><p class="c9"><span class="c8 c28">Overview:</span></p><p class="c9"><span class="c12 c21">In this project we learned how to make a simple rasterizer that would render vector graphics from SVGs files. The fundamental area that we want to approximate is the triangle since it is simple and easily breaks up other polygons. Once we figured out how to draw single color triangles we could get a basic render that looked decent from a distance. However, if we zoomed in and looked closely at the pixels it would have aliasing. To deal with that we did supersampling which would basically average out the color of a point which makes the image smoother and contain less high frequencies. We also wanted to add some dynamics to our renderer which requires applying linear transformations to our coordinates. Finally, we wanted to add textures to our world space. To map the texture space onto the world space we had to sample the textures using pixel sampling and/or level sampling and then interpolate colors across triangles using barycentric coordinates.</span></p><p class="c23"><span class="c10">Task 1: Drawing Single-Color Triangles</span></p><ul class="c1 lst-kix_1k9f929ifvzg-0 start"><li class="c4 li-bullet-0"><span class="c8 c0">Walk through how you rasterize triangles in your own words.</span></li></ul><ul class="c1 lst-kix_1k9f929ifvzg-1 start"><li class="c17 li-bullet-0"><span class="c12 c0">I decided to make a bounding box around the triangle that is going to be rasterized by finding the min and max of the x and y coordinates of each of its vertices. I can now just loop through all the (i, j) pairs within this bounding box (min(x) &lt;= i &lt;= max(x) and min(y) &lt;= j &lt;= max(y) ) and check if each point is within the triangle.</span></li><li class="c17 li-bullet-0"><span class="c0">To check whether each point is within the triangle I simply do the three line test shown in lecture by setting up the equations</span><img src="images/image1.png"><span class="c0">, where </span><img src="images/image2.png"><span class="c12 c0">&nbsp; form one of the three sides of the triangle. Then I just plug in the point I&rsquo;m testing into each of the three equations and see if they&rsquo;re all greater than 0 or less than 0 to account for possibly choosing the sides in the wrong direction (clockwise/counterclockwise).</span></li><li class="c17 li-bullet-0"><span class="c12 c0">After making sure the point is within the triangle, I fill in the point by calling fill_point(x, y, color), with the color that was passed in.</span></li></ul><ul class="c1 lst-kix_1k9f929ifvzg-0"><li class="c4 li-bullet-0"><span class="c8 c0">Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</span></li></ul><ul class="c1 lst-kix_1k9f929ifvzg-1 start"><li class="c17 li-bullet-0"><span class="c12 c0">I create the smallest box I can around the triangle by finding the min and max of the x and y coordinates of each of its vertices so it should be the same as the bounding box of the triangle.</span></li></ul><ul class="c1 lst-kix_1k9f929ifvzg-0"><li class="c4 li-bullet-0"><span class="c0 c11">Show a </span><span class="c7 c0">png</span><span class="c0 c11">&nbsp;screenshot of </span><span class="c7 c0">basic/test4.svg</span><span class="c8 c0">&nbsp;with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</span></li></ul><ul class="c1 lst-kix_1k9f929ifvzg-1 start"><li class="c17 li-bullet-0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 481.00px; height: 323.00px;"><img alt="" src="images/image27.png" style="width: 624.00px; height: 323.00px; margin-left: -143.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li></ul><p class="c23"><span class="c10">Task 2: Antialiasing by Supersampling</span></p><ul class="c1 lst-kix_hhn1i4512df1-0 start"><li class="c4 li-bullet-0"><span class="c8 c0">Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</span></li></ul><ul class="c1 lst-kix_hhn1i4512df1-1 start"><li class="c17 li-bullet-0"><span class="c12 c0">Supersampling is useful because it can help reduce aliasing in an image by basically blurring the pixels of a higher resolution image to create the one we want. By doing this we can conserve more information from the original structure as we average the pixels together instead of just excluding some pixels to reduce the resolution.</span></li><li class="c17 li-bullet-0"><span class="c0">For my supersampling algorithm, at each point (x, y) I loop over an (n x n) region where n = sqrt(sample_rate) to find all the subpixels. Specifically I find what the radius should be for each pixel, </span><img src="images/image3.png"><span class="c0">, to calculate the position of each pixel in the region, </span><img src="images/image4.png"><span class="c0">&nbsp;and </span><img src="images/image5.png"><span class="c0">&nbsp;for the (k, l) pixel in the (n x n) region. Then I just pass </span><img src="images/image6.png"><span class="c12 c0">&nbsp;into my three line test discussed in the previous task to see if it&#39;s inside the triangle. If the point is within the triangle I fill the pixel with the color passed into the rasterization function.</span></li><li class="c17 li-bullet-0"><span class="c0">To make sure the sample_buffer is the correct size, I changed every line in rasterizer.cpp that resized the sample_buffer to now resize the buffer to have (width * height * sample_rate) elements instead of (width * height) elements. Also, in fill_pixel I changed the indexing of the sample_buffer to be </span><img src="images/image7.png"><span class="c0">&nbsp; where n = sqrt(sample_rate) from </span><img src="images/image8.png"><span class="c12 c0">&nbsp;since the width of the sample_buffer is now sqrt(sample_rate) times as big.</span></li><li class="c17 li-bullet-0"><span class="c0">In the resolve_to_framebuffer() function I used the values in my sample_buffer to antialias my image by averaging the colors of all the pixels in the </span><img src="images/image9.png"><span class="c12 c0">&nbsp;region of the corresponding larger pixel.</span></li></ul><ul class="c1 lst-kix_hhn1i4512df1-0"><li class="c4 li-bullet-0"><span class="c0 c11">Show </span><span class="c7 c0">png</span><span class="c0 c11">&nbsp;screenshots of </span><span class="c7 c0">basic/test4.svg</span><span class="c8 c0">&nbsp;with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</span></li></ul><ul class="c1 lst-kix_hhn1i4512df1-1 start"><li class="c17 li-bullet-0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 456.00px; height: 323.00px;"><img alt="" src="images/image37.png" style="width: 624.00px; height: 323.00px; margin-left: -168.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 438.00px; height: 323.00px;"><img alt="" src="images/image34.png" style="width: 624.00px; height: 323.00px; margin-left: -186.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 443.00px; height: 323.00px;"><img alt="" src="images/image33.png" style="width: 624.00px; height: 323.00px; margin-left: -181.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup></li><li class="c17 li-bullet-0"><span class="c12 c0">As we increase the sample rate, there are more pixels with different colors because we need to average more values together to determine their colors. This creates a smoothing effect at the edges and corners which is why increasing the sample rate makes shapes look better in the final image.</span></li></ul><p class="c16"><span class="c10">Task 3: Transforms</span><span class="c5 c0">&nbsp;</span></p><ul class="c1 lst-kix_4qc2v0utgup0-0 start"><li class="c4 li-bullet-0"><span class="c0 c11">Create an updated version of </span><span class="c7 c0">svg/transforms/robot.svg</span><span class="c0 c11">&nbsp;with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your </span><span class="c7 c0">svg</span><span class="c0 c11">&nbsp;file as </span><span class="c7 c0">my_robot.svg</span><span class="c0 c11">&nbsp;in your </span><span class="c7 c0">docs/</span><span class="c0 c11">&nbsp;directory and show a </span><span class="c7 c0">png</span><span class="c0 c8">&nbsp;screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.</span></li></ul><ul class="c1 lst-kix_4qc2v0utgup0-1 start"><li class="c17 li-bullet-0"><span class="c0">I tried to get my cubeman to wave with their right hand<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image26.png" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li></ul><p class="c16"><span class="c2">Task 4: Barycentric coordinates</span></p><ul class="c1 lst-kix_pf4spjyd00kr-0 start"><li class="c4 li-bullet-0"><span class="c0 c11">Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a </span><span class="c7 c0">svg</span><span class="c8 c0">&nbsp;file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.</span></li></ul><ul class="c1 lst-kix_pf4spjyd00kr-1 start"><li class="c17 li-bullet-0"><span class="c0">Barycentric coordinates are coordinates to describe points relative to the vertices of a triangle. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 383.70px; height: 296.34px;"><img alt="" src="images/image35.png" style="width: 383.70px; height: 296.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">&nbsp;<br>For example, in the above photo the point V can be described by three values, </span><img src="images/image10.png"><span class="c0">, where </span><img src="images/image11.png"><span class="c0">&nbsp;and </span><img src="images/image12.png"><span class="c0">&nbsp;are the vertices of the triangle. Specifically, if we were to set </span><img src="images/image13.png"><span class="c0">&nbsp;to 0 and </span><img src="images/image14.png"><span class="c0">&nbsp;to 1, V would be located on vertex C, </span><img src="images/image15.png"><span class="c0">, since it has all the value. Normally the three values </span><img src="images/image10.png"><span class="c0">, are non negative if we want the pixel to be within the triangle and it needs to satisfy the equation </span><img src="images/image16.png"><span class="c0">. These coordinates can be used to linearly interpolate different values for a point within a triangle such as its location, color, and/or texture. In the image above, we can find the correct value for V based off the color of each vertex by linear interpolation using the three values </span><img src="images/image10.png"><span class="c0">&nbsp;and the color of each vertex, </span><img src="images/image17.png"><span class="c0">. To find the values of </span><img src="images/image10.png"><span class="c0">&nbsp;we must use the values of the three line test for the point V and also plugging in each vertex that is not on the line, plugging in the coordinates of </span><img src="images/image18.png"><span class="c0">&nbsp;into the line test equation for the line </span><img src="images/image19.png"><span class="c0">. Then we can use these calculated values to find </span><img src="images/image20.png"><span class="c12 c0">.</span></li></ul><ul class="c1 lst-kix_pf4spjyd00kr-0"><li class="c4 li-bullet-0"><span class="c0 c11">Show a </span><span class="c7 c0">png</span><span class="c0 c11">&nbsp;screenshot of </span><span class="c7 c0">svg/basic/test7.svg</span><span class="c8 c0">&nbsp;with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.</span></li></ul><ul class="c1 lst-kix_pf4spjyd00kr-1 start"><li class="c17 li-bullet-0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 334.00px; height: 323.00px;"><img alt="" src="images/image38.png" style="width: 624.00px; height: 323.00px; margin-left: -142.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></li></ul><p class="c16"><span class="c2">Task 5: &quot;Pixel sampling&quot; for texture mapping</span></p><ul class="c1 lst-kix_xejd8s2iujbr-0 start"><li class="c4 li-bullet-0"><span class="c8 c0">Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</span></li></ul><ul class="c1 lst-kix_xejd8s2iujbr-1 start"><li class="c17 li-bullet-0"><span class="c12 c0">Pixel sampling is how we determine the texture we assign a point with a given (u, v) coordinate in texture space. When we map a point from image space to texture space, we may get coordinates that fall between two integers so we need to implement a way to decide what the texture should be based on the values around it. </span></li><li class="c17 li-bullet-0"><span class="c0">One of the ways for pixel sampling is nearest sampling where we just round the (u, v) coordinates we have to their closest integers and use the texture from that point. Another method is bilinear sampling where we take the closest four points in texture space to (u, v) and create a linear combination of their texture values based on how far each point is from the original (u, v) coordinates. <br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 255.00px; height: 357.00px;"><img alt="" src="images/image42.png" style="width: 255.00px; height: 357.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0"><br>In the image above, the texture of our point (x, y) will be the texture of one of the corners </span><img src="images/image21.png"><span class="c12 c0">&nbsp;scaled by the area of the square touching the opposite corner (i.e. the texture of the yellow point * the area of the yellow region). Basically, if our point (x, y) is closer to a given corner, the associated region of that corner will have a larger area, thus contributing more to the texture value of (x, y).</span></li><li class="c17 li-bullet-0"><span class="c0">To implement pixel sampling I first found the coordinates of a pixel in texture space from its location in image space using the barycentric coordinates of the point, </span><img src="images/image10.png"><span class="c0">. To find u and v I just calculate the linear combination of the texture coordinates of the vertices of the triangle, </span><img src="images/image22.png"><span class="c0">), with the barycentric coordinates of the point, </span><img src="images/image23.png"><span class="c12 c0">. Now I would just pass the (u, v) I calculated and perform one of the two methods I described above using the round, floor, and ceil functions to get the nearest coordinate(s) so I can use their texture values to find the correct value for my current point..</span></li></ul><ul class="c1 lst-kix_xejd8s2iujbr-0"><li class="c4 li-bullet-0"><span class="c0 c11">Check out the </span><span class="c7 c0">svg</span><span class="c0 c11">&nbsp;files in the </span><span class="c7 c0">svg/texmap/</span><span class="c0 c11">&nbsp;directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four </span><span class="c0 c7">png</span><span class="c8 c0">&nbsp;screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</span></li></ul><p class="c16 c25"><span class="c14 c0">Bilinear Sampling, 1 sample/pixel</span><span class="c0"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 471.00px; height: 323.00px;"><img alt="" src="images/image40.png" style="width: 624.00px; height: 323.00px; margin-left: -153.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup><span class="c0"><br><br></span><span class="c14 c0">Bilinear Sampling, 16 samples/pixel</span><span class="c0"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 468.00px; height: 323.00px;"><img alt="" src="images/image29.png" style="width: 624.00px; height: 323.00px; margin-left: -156.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup><span class="c0"><br><br></span><span class="c0 c14">Nearest Sampling, 1 sample/pixel</span><span class="c0"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.00px; height: 323.00px;"><img alt="" src="images/image32.png" style="width: 624.00px; height: 323.00px; margin-left: -157.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><span class="c0"><br><br></span><span class="c14 c0">Nearest Sampling, 16 samples/pixel</span><span class="c0"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.00px; height: 323.00px;"><img alt="" src="images/image36.png" style="width: 624.00px; height: 323.00px; margin-left: -157.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup></p><ul class="c1 lst-kix_xejd8s2iujbr-0"><li class="c4 li-bullet-0"><span class="c8 c0">Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</span></li></ul><ul class="c1 lst-kix_xejd8s2iujbr-1 start"><li class="c17 li-bullet-0"><span class="c12 c0">In the 1 sample per pixel case, bilinear sampling looks better than nearest as it&rsquo;s blending the values of nearby pixels so the drop off seems very fluid. On the other hand, nearest sampling is only using the value of the nearest pixel so the pixels are either really white or really blue and there isn&rsquo;t an in-between color causing there to be a distinct drop off in the white line.</span></li></ul><p class="c16"><span class="c2">Task 6: &quot;Level sampling&quot; with mipmaps for texture mapping</span></p><ul class="c1 lst-kix_qv5n0jwtl5za-0 start"><li class="c4 li-bullet-0"><span class="c8 c0">Explain level sampling in your own words and describe how you implemented it for texture mapping.</span></li></ul><ul class="c1 lst-kix_qv5n0jwtl5za-1 start"><li class="c17 li-bullet-0"><span class="c0 c12">Level sampling involves creating a pyramid of downsized images that can be used to use pixels at different resolutions when doing pixel sampling. When we have an image whose content is supposed to get farther and farther such as a picture of a room where the back wall appears small, aliasing may occur to lines on these far away walls but not necessarily to content that is up close in the image. This happens because this far away content is usually very small. At very short pixel distances we may have a big jump in texture space so it may look better if we used pixels from a lower resolution version of the image which have more of a blurred texture. </span></li><li class="c17 li-bullet-0"><span class="c0">To implement level sampling I found </span><img src="images/image24.png"><span class="c0">&nbsp;and </span><img src="images/image25.png"><span class="c0">&nbsp;using the <br>(u, v) coordinates of current point (x, y) and two that are 1 unit away, <br>(x+1, y) and (x, y+1). Specifically, I found the differences between the (u, v) coordinates of my original point (x, y) with the coordinates of (x+1, y) and (x, y+1). With theses derivatives, I found the best level to sample from for the given point using the equation that was given to us in lecture, <br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 522.50px; height: 122.89px;"><img alt="" src="images/image30.png" style="width: 536.25px; height: 122.89px; margin-left: -13.75px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c12 c0"><br>where D is the level. I would then just feed this level into my pixel sampling methods so they know from which level to sample texture values. For nearest level sampling, I simply just rounded the value D I got from the above equation and for the linear sample method I computed a weighted linear combination of the results from using the floor and ceiling of the current D value as the level. The weights would just be (D - floor(D)) and (ceil(D) - D).</span></li></ul><ul class="c1 lst-kix_qv5n0jwtl5za-0"><li class="c4 li-bullet-0"><span class="c8 c0">You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.</span></li></ul><ul class="c1 lst-kix_qv5n0jwtl5za-1 start"><li class="c17 li-bullet-0"><span class="c12 c0">Pixel sampling is the fastest of the three techniques as it only requires looking at 4 nearby pixels while level sampling requires an image pyramid to be made and supersampling requires sample_rate times more iterations when filling out the sample buffer. </span></li><li class="c17 li-bullet-0"><span class="c12 c0">Pixel sampling requires the least amount of memory usage as we only need to look at 4 nearby pixels while supersampling requires sample_rate times more memory to hold our high resolution version of the image. Also level sampling requires more memory usage than pixel sampling as we need to store the image at different resolutions so we can access pixels at different levels.</span></li><li class="c17 li-bullet-0"><span class="c12 c0">Level sampling probably has the most antialiasing power as not all parts of an image will look good if we use pixel values just from one fixed resolution as supersampling and pixel sampling do. With level sampling, different pixels can use pixels from the image at different resolutions to account for possibly big jumps surrounding their texture space coordinates. </span></li></ul><ul class="c1 lst-kix_qv5n0jwtl5za-0"><li class="c4 li-bullet-0"><span class="c0 c11">Using a </span><span class="c7 c0">png</span><span class="c0 c11">&nbsp;file you find yourself, show us four versions of the image, using the combinations of </span><span class="c22 c11 c15">L_ZERO</span><span class="c0 c11">&nbsp;and </span><span class="c22 c11 c15">P_NEAREST</span><span class="c0 c11">, </span><span class="c22 c11 c15">L_ZERO</span><span class="c0 c11">&nbsp;and </span><span class="c22 c11 c15">P_LINEAR</span><span class="c0 c11">, </span><span class="c22 c11 c15">L_NEAREST</span><span class="c0 c11">&nbsp;and </span><span class="c22 c11 c15">P_NEAREST</span><span class="c0 c11">, as well as </span><span class="c22 c11 c15">L_NEAREST</span><span class="c0 c11">&nbsp;and </span><span class="c22 c11 c15">P_LINEAR</span><span class="c0 c11">.</span></li></ul><p class="c16 c20"><span class="c0 c11 c15">L_ZERO</span><span class="c11 c13">&nbsp;and </span><span class="c0 c11 c15">P_NEAREST</span><span class="c11 c15 c22"><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 322.67px;"><img alt="" src="images/image28.png" style="width: 624.00px; height: 322.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c22 c11 c15"><br><br></span><span class="c0 c11 c15">L_ZERO</span><span class="c13 c11">&nbsp;and </span><span class="c0 c11 c15">P_LINEAR<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 322.67px;"><img alt="" src="images/image41.png" style="width: 624.00px; height: 322.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0 c11 c15"><br><br>L_NEAREST</span><span class="c13 c11">&nbsp;and </span><span class="c0 c11 c15">P_NEAREST<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 322.67px;"><img alt="" src="images/image39.png" style="width: 624.00px; height: 322.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0 c11 c15"><br><br>L_NEAREST</span><span class="c13 c11">&nbsp;and </span><span class="c0 c11 c15">P_LINEAR<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 322.67px;"><img alt="" src="images/image31.png" style="width: 624.00px; height: 322.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c24"><span class="c12 c0"></span></p><p class="c24"><span class="c0 c5"></span></p><p class="c9 c29"><span class="c8 c30"></span></p><div class="c18"><p class="c19"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c3">Sample rate 1</span></p></div><div class="c18"><p class="c19"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c3">Sample rate 4</span></p></div><div class="c18"><p class="c19"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c3">Sample rate 16</span></p></div><div class="c18"><p class="c19"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c3">bilinear, 1 sample per pixel</span></p></div><div class="c18"><p class="c19"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c3">bilinear, 16 samples per pixel</span></p></div><div class="c18"><p class="c19"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c3">nearest, 1 sample per pixel</span></p></div><div class="c18"><p class="c19"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c3">nearest, 16 samples per pixel</span></p></div></body></html>